// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/smallq_class/dao/model"
)

func newGenTable(db *gorm.DB, opts ...gen.DOOption) genTable {
	_genTable := genTable{}

	_genTable.genTableDo.UseDB(db, opts...)
	_genTable.genTableDo.UseModel(&model.GenTable{})

	tableName := _genTable.genTableDo.TableName()
	_genTable.ALL = field.NewAsterisk(tableName)
	_genTable.TableID = field.NewInt64(tableName, "table_id")
	_genTable.TableName_ = field.NewString(tableName, "table_name")
	_genTable.ParentMenuID = field.NewInt64(tableName, "parent_menu_id")
	_genTable.TableComment = field.NewString(tableName, "table_comment")
	_genTable.SubTableName = field.NewString(tableName, "sub_table_name")
	_genTable.SubTableFkName = field.NewString(tableName, "sub_table_fk_name")
	_genTable.StructName = field.NewString(tableName, "struct_name")
	_genTable.TplCategory = field.NewString(tableName, "tpl_category")
	_genTable.PackageName = field.NewString(tableName, "package_name")
	_genTable.ModuleName = field.NewString(tableName, "module_name")
	_genTable.BusinessName = field.NewString(tableName, "business_name")
	_genTable.FunctionName = field.NewString(tableName, "function_name")
	_genTable.FunctionAuthor = field.NewString(tableName, "function_author")
	_genTable.Options = field.NewString(tableName, "options")
	_genTable.CreateBy = field.NewInt64(tableName, "create_by")
	_genTable.CreateTime = field.NewTime(tableName, "create_time")
	_genTable.UpdateBy = field.NewInt64(tableName, "update_by")
	_genTable.UpdateTime = field.NewTime(tableName, "update_time")
	_genTable.Remark = field.NewString(tableName, "remark")

	_genTable.fillFieldMap()

	return _genTable
}

// genTable 代码生成业务表
type genTable struct {
	genTableDo genTableDo

	ALL            field.Asterisk
	TableID        field.Int64  // 编号
	TableName_     field.String // 表名称
	ParentMenuID   field.Int64  // 父菜单ID
	TableComment   field.String // 表描述
	SubTableName   field.String // 关联子表的表名
	SubTableFkName field.String // 子表关联的外键名
	StructName     field.String // 结构体名称
	TplCategory    field.String // 使用的模板（crud单表操作 tree树表操作 sub主子表操作）
	PackageName    field.String // 生成包路径
	ModuleName     field.String // 生成模块名
	BusinessName   field.String // 生成业务名
	FunctionName   field.String // 生成功能名
	FunctionAuthor field.String // 生成功能作者
	Options        field.String // 其它生成选项
	CreateBy       field.Int64  // 创建者
	CreateTime     field.Time   // 创建时间
	UpdateBy       field.Int64  // 更新者
	UpdateTime     field.Time   // 更新时间
	Remark         field.String // 备注

	fieldMap map[string]field.Expr
}

func (g genTable) Table(newTableName string) *genTable {
	g.genTableDo.UseTable(newTableName)
	return g.updateTableName(newTableName)
}

func (g genTable) As(alias string) *genTable {
	g.genTableDo.DO = *(g.genTableDo.As(alias).(*gen.DO))
	return g.updateTableName(alias)
}

func (g *genTable) updateTableName(table string) *genTable {
	g.ALL = field.NewAsterisk(table)
	g.TableID = field.NewInt64(table, "table_id")
	g.TableName_ = field.NewString(table, "table_name")
	g.ParentMenuID = field.NewInt64(table, "parent_menu_id")
	g.TableComment = field.NewString(table, "table_comment")
	g.SubTableName = field.NewString(table, "sub_table_name")
	g.SubTableFkName = field.NewString(table, "sub_table_fk_name")
	g.StructName = field.NewString(table, "struct_name")
	g.TplCategory = field.NewString(table, "tpl_category")
	g.PackageName = field.NewString(table, "package_name")
	g.ModuleName = field.NewString(table, "module_name")
	g.BusinessName = field.NewString(table, "business_name")
	g.FunctionName = field.NewString(table, "function_name")
	g.FunctionAuthor = field.NewString(table, "function_author")
	g.Options = field.NewString(table, "options")
	g.CreateBy = field.NewInt64(table, "create_by")
	g.CreateTime = field.NewTime(table, "create_time")
	g.UpdateBy = field.NewInt64(table, "update_by")
	g.UpdateTime = field.NewTime(table, "update_time")
	g.Remark = field.NewString(table, "remark")

	g.fillFieldMap()

	return g
}

func (g *genTable) WithContext(ctx context.Context) *genTableDo { return g.genTableDo.WithContext(ctx) }

func (g genTable) TableName() string { return g.genTableDo.TableName() }

func (g genTable) Alias() string { return g.genTableDo.Alias() }

func (g genTable) Columns(cols ...field.Expr) gen.Columns { return g.genTableDo.Columns(cols...) }

func (g *genTable) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := g.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (g *genTable) fillFieldMap() {
	g.fieldMap = make(map[string]field.Expr, 19)
	g.fieldMap["table_id"] = g.TableID
	g.fieldMap["table_name"] = g.TableName_
	g.fieldMap["parent_menu_id"] = g.ParentMenuID
	g.fieldMap["table_comment"] = g.TableComment
	g.fieldMap["sub_table_name"] = g.SubTableName
	g.fieldMap["sub_table_fk_name"] = g.SubTableFkName
	g.fieldMap["struct_name"] = g.StructName
	g.fieldMap["tpl_category"] = g.TplCategory
	g.fieldMap["package_name"] = g.PackageName
	g.fieldMap["module_name"] = g.ModuleName
	g.fieldMap["business_name"] = g.BusinessName
	g.fieldMap["function_name"] = g.FunctionName
	g.fieldMap["function_author"] = g.FunctionAuthor
	g.fieldMap["options"] = g.Options
	g.fieldMap["create_by"] = g.CreateBy
	g.fieldMap["create_time"] = g.CreateTime
	g.fieldMap["update_by"] = g.UpdateBy
	g.fieldMap["update_time"] = g.UpdateTime
	g.fieldMap["remark"] = g.Remark
}

func (g genTable) clone(db *gorm.DB) genTable {
	g.genTableDo.ReplaceConnPool(db.Statement.ConnPool)
	return g
}

func (g genTable) replaceDB(db *gorm.DB) genTable {
	g.genTableDo.ReplaceDB(db)
	return g
}

type genTableDo struct{ gen.DO }

func (g genTableDo) Debug() *genTableDo {
	return g.withDO(g.DO.Debug())
}

func (g genTableDo) WithContext(ctx context.Context) *genTableDo {
	return g.withDO(g.DO.WithContext(ctx))
}

func (g genTableDo) ReadDB() *genTableDo {
	return g.Clauses(dbresolver.Read)
}

func (g genTableDo) WriteDB() *genTableDo {
	return g.Clauses(dbresolver.Write)
}

func (g genTableDo) Session(config *gorm.Session) *genTableDo {
	return g.withDO(g.DO.Session(config))
}

func (g genTableDo) Clauses(conds ...clause.Expression) *genTableDo {
	return g.withDO(g.DO.Clauses(conds...))
}

func (g genTableDo) Returning(value interface{}, columns ...string) *genTableDo {
	return g.withDO(g.DO.Returning(value, columns...))
}

func (g genTableDo) Not(conds ...gen.Condition) *genTableDo {
	return g.withDO(g.DO.Not(conds...))
}

func (g genTableDo) Or(conds ...gen.Condition) *genTableDo {
	return g.withDO(g.DO.Or(conds...))
}

func (g genTableDo) Select(conds ...field.Expr) *genTableDo {
	return g.withDO(g.DO.Select(conds...))
}

func (g genTableDo) Where(conds ...gen.Condition) *genTableDo {
	return g.withDO(g.DO.Where(conds...))
}

func (g genTableDo) Order(conds ...field.Expr) *genTableDo {
	return g.withDO(g.DO.Order(conds...))
}

func (g genTableDo) Distinct(cols ...field.Expr) *genTableDo {
	return g.withDO(g.DO.Distinct(cols...))
}

func (g genTableDo) Omit(cols ...field.Expr) *genTableDo {
	return g.withDO(g.DO.Omit(cols...))
}

func (g genTableDo) Join(table schema.Tabler, on ...field.Expr) *genTableDo {
	return g.withDO(g.DO.Join(table, on...))
}

func (g genTableDo) LeftJoin(table schema.Tabler, on ...field.Expr) *genTableDo {
	return g.withDO(g.DO.LeftJoin(table, on...))
}

func (g genTableDo) RightJoin(table schema.Tabler, on ...field.Expr) *genTableDo {
	return g.withDO(g.DO.RightJoin(table, on...))
}

func (g genTableDo) Group(cols ...field.Expr) *genTableDo {
	return g.withDO(g.DO.Group(cols...))
}

func (g genTableDo) Having(conds ...gen.Condition) *genTableDo {
	return g.withDO(g.DO.Having(conds...))
}

func (g genTableDo) Limit(limit int) *genTableDo {
	return g.withDO(g.DO.Limit(limit))
}

func (g genTableDo) Offset(offset int) *genTableDo {
	return g.withDO(g.DO.Offset(offset))
}

func (g genTableDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *genTableDo {
	return g.withDO(g.DO.Scopes(funcs...))
}

func (g genTableDo) Unscoped() *genTableDo {
	return g.withDO(g.DO.Unscoped())
}

func (g genTableDo) Create(values ...*model.GenTable) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Create(values)
}

func (g genTableDo) CreateInBatches(values []*model.GenTable, batchSize int) error {
	return g.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (g genTableDo) Save(values ...*model.GenTable) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Save(values)
}

func (g genTableDo) First() (*model.GenTable, error) {
	if result, err := g.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.GenTable), nil
	}
}

func (g genTableDo) Take() (*model.GenTable, error) {
	if result, err := g.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.GenTable), nil
	}
}

func (g genTableDo) Last() (*model.GenTable, error) {
	if result, err := g.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.GenTable), nil
	}
}

func (g genTableDo) Find() ([]*model.GenTable, error) {
	result, err := g.DO.Find()
	return result.([]*model.GenTable), err
}

func (g genTableDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GenTable, err error) {
	buf := make([]*model.GenTable, 0, batchSize)
	err = g.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (g genTableDo) FindInBatches(result *[]*model.GenTable, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return g.DO.FindInBatches(result, batchSize, fc)
}

func (g genTableDo) Attrs(attrs ...field.AssignExpr) *genTableDo {
	return g.withDO(g.DO.Attrs(attrs...))
}

func (g genTableDo) Assign(attrs ...field.AssignExpr) *genTableDo {
	return g.withDO(g.DO.Assign(attrs...))
}

func (g genTableDo) Joins(fields ...field.RelationField) *genTableDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Joins(_f))
	}
	return &g
}

func (g genTableDo) Preload(fields ...field.RelationField) *genTableDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Preload(_f))
	}
	return &g
}

func (g genTableDo) FirstOrInit() (*model.GenTable, error) {
	if result, err := g.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.GenTable), nil
	}
}

func (g genTableDo) FirstOrCreate() (*model.GenTable, error) {
	if result, err := g.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.GenTable), nil
	}
}

func (g genTableDo) FindByPage(offset int, limit int) (result []*model.GenTable, count int64, err error) {
	result, err = g.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = g.Offset(-1).Limit(-1).Count()
	return
}

func (g genTableDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = g.Count()
	if err != nil {
		return
	}

	err = g.Offset(offset).Limit(limit).Scan(result)
	return
}

func (g genTableDo) Scan(result interface{}) (err error) {
	return g.DO.Scan(result)
}

func (g genTableDo) Delete(models ...*model.GenTable) (result gen.ResultInfo, err error) {
	return g.DO.Delete(models)
}

func (g *genTableDo) withDO(do gen.Dao) *genTableDo {
	g.DO = *do.(*gen.DO)
	return g
}
